// Generated by CoffeeScript 1.3.3
(function() {
  var Puzzle, _;

  _ = {
    isArray: Array.isArray || function(value) {
      return value instanceof Array || toString.call(value) === '[object Array]';
    },
    flatten: function(array, isShallow) {
      var index, length, result, value;
      index = -1;
      length = array ? array.length : 0;
      result = [];
      if (typeof isShallow === 'boolean' && isShallow === !null) {
        isShallow = false;
      }
      while (++index < length) {
        value = array[index];
        if (_.isArray(value)) {
          result.push.apply(result, isShallow ? value : _.flatten(value));
        } else {
          result.push(value);
        }
      }
      return result;
    }
  };

  window.Puzzle = Puzzle = (function() {

    function Puzzle() {}

    Puzzle.prototype.strokeStyle = 'rgba(255, 0, 0, 0.25)';

    Puzzle.prototype.samenessThreshold = 0.05;

    Puzzle.prototype.comparators = {
      isMuchDarker: function(v, min, upperMin) {
        if (min === false || upperMin === false) {
          return false;
        }
        if (v >= min && v < upperMin) {
          return -2;
        } else {
          return false;
        }
      },
      isDarker: function(v, upperMin, center) {
        if (upperMin === false) {
          return false;
        }
        if (v >= upperMin && v < (center - 2)) {
          return -1;
        } else {
          return false;
        }
      },
      isSame: function(v, center) {
        if ((center - 2) <= v && v <= (center + 2)) {
          return 0;
        } else {
          return false;
        }
      },
      isLighter: function(v, center, lowerMax) {
        if (lowerMax === false) {
          return false;
        }
        if (v > (center + 2) && v <= lowerMax) {
          return 1;
        } else {
          return false;
        }
      },
      isMuchLighter: function(v, lowerMax, max) {
        if (max === false || lowerMax === false) {
          return false;
        }
        if (v > lowerMax && v <= max) {
          return 2;
        } else {
          return false;
        }
      }
    };

    Puzzle.prototype.getImageSignature = function(img) {
      var canvas;
      canvas = this.createCanvas(img.width, img.height);
      this.drawImageOnCanvas(canvas, img);
      return this.computeVectorPoints(canvas);
    };

    Puzzle.prototype.createCanvas = function(w, h) {
      var c;
      c = document.createElement('canvas');
      c.width = w;
      c.height = h;
      c.id = 'canvas';
      return document.body.appendChild(c);
    };

    Puzzle.prototype.drawImageOnCanvas = function(canvas, image) {
      var b, ctx, g, i, imgData, r, v, _i, _ref;
      ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0);
      imgData = ctx.getImageData(0, 0, image.width, image.height);
      for (i = _i = 0, _ref = imgData.data.length; _i <= _ref; i = _i += 4) {
        r = imgData.data[i];
        g = imgData.data[i + 1];
        b = imgData.data[i + 2];
        v = Math.floor(0.2126 * r + 0.7152 * g + 0.0722 * b);
        imgData.data[i] = imgData.data[i + 1] = imgData.data[i + 2] = v;
      }
      return ctx.putImageData(imgData, 0, 0);
    };

    Puzzle.prototype.computeVectorPoints = function(canvas) {
      var cols, colsToCrop, handlePoints, height, imgData, p, rows, rowsToCrop, vector, vectorArray, width;
      width = canvas.width;
      height = canvas.height;
      imgData = canvas.getContext('2d').getImageData(0, 0, width, height);
      rows = this.collatePixelRows(imgData, width, height);
      cols = this.collatePixelColumns(imgData, width, height);
      rowsToCrop = this.calcCrop(rows, height, 'rows');
      colsToCrop = this.calcCrop(cols, width, 'cols');
      this.cropRows(canvas, rowsToCrop);
      this.cropCols(canvas, colsToCrop);
      handlePoints = this.computeHandlePoints(canvas);
      this.gridifyImage(canvas, handlePoints);
      p = this.computePValue(canvas);
      handlePoints = this.computeAverageGrayLevels(canvas, handlePoints, p);
      this.addSampleSquaresToImage(canvas, handlePoints, p);
      vectorArray = this.computeRelativeNeighborGrayLevels(handlePoints);
      vector = [].concat.apply([], vectorArray);
      return console.log(vector, vector.length);
    };

    Puzzle.prototype.computeRelativeNeighborGrayLevels = function(handles) {
      var center, colIndex, i, lowerMax, matrix, max, min, n, neighbors, rNeighbors, rowIndex, upperMin, v, vectorArray, _i, _j, _k, _len, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
        _this = this;
      matrix = [];
      i = 0;
      while (i < 9) {
        matrix.push(handles.slice(i * 9, i * 9 + 9)) && i++;
      }
      vectorArray = [];
      for (rowIndex = _i = 0, _ref = matrix.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; rowIndex = 0 <= _ref ? ++_i : --_i) {
        for (colIndex = _j = 0, _ref1 = matrix[rowIndex].length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; colIndex = 0 <= _ref1 ? ++_j : --_j) {
          neighbors = [(_ref2 = matrix[rowIndex - 1]) != null ? (_ref3 = _ref2[colIndex - 1]) != null ? _ref3.fill : void 0 : void 0, (_ref4 = matrix[rowIndex - 1]) != null ? (_ref5 = _ref4[colIndex]) != null ? _ref5.fill : void 0 : void 0, (_ref6 = matrix[rowIndex - 1]) != null ? (_ref7 = _ref6[colIndex + 1]) != null ? _ref7.fill : void 0 : void 0, (_ref8 = matrix[rowIndex]) != null ? (_ref9 = _ref8[colIndex - 1]) != null ? _ref9.fill : void 0 : void 0, (_ref10 = matrix[rowIndex]) != null ? (_ref11 = _ref10[colIndex + 1]) != null ? _ref11.fill : void 0 : void 0, (_ref12 = matrix[rowIndex + 1]) != null ? (_ref13 = _ref12[colIndex - 1]) != null ? _ref13.fill : void 0 : void 0, (_ref14 = matrix[rowIndex + 1]) != null ? (_ref15 = _ref14[colIndex]) != null ? _ref15.fill : void 0 : void 0, (_ref16 = matrix[rowIndex + 1]) != null ? (_ref17 = _ref16[colIndex + 1]) != null ? _ref17.fill : void 0 : void 0];
          center = matrix[rowIndex][colIndex].fill;
          min = (function() {
            return Math.min.apply(Math, neighbors.filter(Number));
          })();
          if (center < min) {
            min = false;
          }
          max = (function() {
            return Math.max.apply(Math, neighbors.filter(Number));
          })();
          if (center > lowerMax) {
            max = false;
          }
          upperMin = (function() {
            var tolerance, v;
            tolerance = Math.floor((center - min) * _this.samenessThreshold);
            v = Math.floor((min + (center - tolerance)) / 2);
            if (center < v) {
              return false;
            } else {
              return v;
            }
          })();
          lowerMax = (function() {
            var tolerance, v;
            tolerance = Math.floor((max - center) * _this.samenessThreshold);
            v = Math.floor((max + (center + tolerance)) / 2);
            if (center > v) {
              return false;
            } else {
              return v;
            }
          })();
          rNeighbors = [];
          for (_k = 0, _len = neighbors.length; _k < _len; _k++) {
            n = neighbors[_k];
            v = this.comparators.isMuchDarker(n, min, upperMin);
            if (v === false) {
              v = this.comparators.isDarker(n, upperMin, center);
            }
            if (v === false) {
              v = this.comparators.isSame(n, center);
            }
            if (v === false) {
              v = this.comparators.isLighter(n, center, lowerMax);
            }
            if (v === false) {
              v = this.comparators.isMuchLighter(n, lowerMax, max);
            }
            if (v === false) {
              v = 0;
            }
            rNeighbors.push(v);
          }
          vectorArray.push(rNeighbors);
        }
      }
      return vectorArray;
    };

    Puzzle.prototype.computeAverageGrayLevels = function(canvas, handles, p) {
      var ctx, imgData, pixel, point, sum, total, _i, _j, _len, _len1, _ref, _step;
      ctx = canvas.getContext('2d');
      for (_i = 0, _len = handles.length; _i < _len; _i++) {
        point = handles[_i];
        imgData = ctx.getImageData(point.x - p / 2, point.y - p / 2, p, p);
        sum = 0;
        total = 0;
        _ref = imgData.data;
        for (_j = 0, _len1 = _ref.length, _step = 4; _j < _len1; _j += _step) {
          pixel = _ref[_j];
          sum += pixel;
          total++;
        }
        point.fill = Math.floor(sum / total);
      }
      return handles;
    };

    Puzzle.prototype.addSampleSquaresToImage = function(canvas, handles, p) {
      var c, cToHex, ctx, point, _i, _len, _results;
      ctx = canvas.getContext('2d');
      cToHex = function(c) {
        var hex;
        hex = c.toString(16);
        if (hex.length === 1) {
          return '0' + hex;
        } else {
          return hex;
        }
      };
      _results = [];
      for (_i = 0, _len = handles.length; _i < _len; _i++) {
        point = handles[_i];
        c = "#" + (cToHex(point.fill)) + (cToHex(point.fill)) + (cToHex(point.fill));
        ctx.beginPath();
        ctx.rect(point.x - p / 2, point.y - p / 2, p, p);
        ctx.fillStyle = c;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = this.strokeStyle;
        _results.push(ctx.stroke());
      }
      return _results;
    };

    Puzzle.prototype.computePValue = function(canvas) {
      var P;
      P = function(m, n) {
        return Math.max(2, Math.floor(.5 + Math.min(n, m) / 20));
      };
      return P(canvas.width, canvas.height);
    };

    Puzzle.prototype.computeHandlePoints = function(canvas) {
      var handles, i, interval, x, xInt, xPaths, y, yInt, yPaths, _i, _j, _k, _len, _len1, _ref;
      interval = 10;
      xInt = Math.round(canvas.width / interval);
      yInt = Math.round(canvas.height / interval);
      xPaths = [];
      yPaths = [];
      for (i = _i = 0, _ref = interval - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i !== 0) {
          xPaths.push(Math.round(xInt * i));
          yPaths.push(Math.round(yInt * i));
        }
      }
      handles = [];
      for (_j = 0, _len = yPaths.length; _j < _len; _j++) {
        y = yPaths[_j];
        for (_k = 0, _len1 = xPaths.length; _k < _len1; _k++) {
          x = xPaths[_k];
          handles.push({
            x: x,
            y: y
          });
        }
      }
      return handles;
    };

    Puzzle.prototype.gridifyImage = function(canvas, handles) {
      var ctx, point, x, xPaths, y, yPaths, _i, _j, _k, _len, _len1, _len2, _results;
      xPaths = [];
      yPaths = [];
      for (_i = 0, _len = handles.length; _i < _len; _i++) {
        point = handles[_i];
        if (xPaths.indexOf(point.x) === -1) {
          xPaths.push(point.x);
        }
        if (yPaths.indexOf(point.y) === -1) {
          yPaths.push(point.y);
        }
      }
      ctx = canvas.getContext('2d');
      for (_j = 0, _len1 = xPaths.length; _j < _len1; _j++) {
        x = xPaths[_j];
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.closePath();
        ctx.strokeStyle = this.strokeStyle;
        ctx.stroke();
      }
      _results = [];
      for (_k = 0, _len2 = yPaths.length; _k < _len2; _k++) {
        y = yPaths[_k];
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.closePath();
        ctx.strokeStyle = this.strokeStyle;
        _results.push(ctx.stroke());
      }
      return _results;
    };

    Puzzle.prototype.collatePixelColumns = function(imgData, width, height) {
      var cols, d, diffs, mx, nmx, x, _i, _ref;
      d = imgData.data;
      cols = new Array;
      for (x = _i = 0, _ref = width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        diffs = new Array;
        mx = x * 4;
        nmx = mx + width * 4;
        while (d[nmx] != null) {
          diffs.push(Math.abs(d[mx] - d[nmx]));
          mx = nmx;
          nmx = nmx + width * 4;
        }
        cols.push(diffs.reduce((function(a, b) {
          return a + b;
        }), 0));
      }
      return cols;
    };

    Puzzle.prototype.collatePixelRows = function(imgData, width, height) {
      var col, d, diffs, my, nmy, rows, y, _i, _ref;
      d = imgData.data;
      rows = new Array;
      for (y = _i = 0, _ref = height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        diffs = new Array;
        col = 0;
        my = y * width * 4;
        nmy = my + 4;
        while (col < width && (d[nmy] != null)) {
          diffs.push(Math.abs(d[my] - d[nmy]));
          my = nmy;
          nmy = nmy + 4;
          col++;
        }
        rows.push(diffs.reduce((function(a, b) {
          return a + b;
        }), 0));
      }
      return rows;
    };

    Puzzle.prototype.calcCrop = function(array, dimension, dimensionType) {
      var fivePercent, total;
      total = array.reduce((function(a, b) {
        return a + b;
      }), 0);
      fivePercent = Math.round(total * .05);
      return this.pingPongCrop(array, dimension, fivePercent, dimensionType);
    };

    Puzzle.prototype.pingPongCrop = function(array, max, target, type) {
      var beat, firstCrop, i, min, ret, secondCrop, sum, v;
      min = 0;
      i = 0;
      sum = 0;
      beat = 'tick';
      firstCrop = [];
      secondCrop = [];
      while (sum <= target) {
        if (beat === 'tick') {
          v = array[min + i];
          firstCrop.push(min + i);
          beat = 'tock';
        } else {
          v = array[(max - 1) - i];
          secondCrop.push(max - i);
          i++;
          beat = 'tick';
        }
        sum += v;
      }
      ret = {};
      if (type === 'cols') {
        ret.left = firstCrop.length;
        ret.right = secondCrop.length;
      } else {
        ret.top = firstCrop.length;
        ret.bottom = secondCrop.length;
      }
      return ret;
    };

    Puzzle.prototype.cropCols = function(canvas, colsToCrop) {
      var ctx, imgData;
      ctx = canvas.getContext('2d');
      imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.width = canvas.width - (colsToCrop.left + colsToCrop.right);
      return ctx.putImageData(imgData, -colsToCrop.left, 0);
    };

    Puzzle.prototype.cropRows = function(canvas, rowsToCrop) {
      var ctx, imgData;
      ctx = canvas.getContext('2d');
      imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvas.height - (rowsToCrop.top + rowsToCrop.bottom);
      return ctx.putImageData(imgData, 0, -rowsToCrop.top);
    };

    return Puzzle;

  })();

}).call(this);
